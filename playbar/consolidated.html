
<!--<!doctype html>-->
<!--<html lang="en">-->
<!--<head>-->
<!--  <meta charset="UTF-8" />-->
<!--  <meta name="viewport" content="width=device-width, initial-scale=1.0" />-->
<!--  <title>Custom Audio Waveform Visualizer</title>-->
<link rel="stylesheet" href="styles.css" />
<!--</head>-->
<!--<body>-->
<div class="playlist-container">
  <!-- This container holds all player instances -->

  <!-- Player 1 -->
  <div class="player-container" data-player-id="player1">
    <!-- Song info is now placed before the visualization wrapper -->
    <div class="song-info">
      <div class="song-title">Bull Fight / Sounds of Red Bull 2025</div>
    </div>

    <div class="visualization-wrapper">
      <div class="visualization-container">
        <div class="album-art">
          <img
                  src="https://alex-fortunato.github.io/Website/playbar/assets/red-bull-logo.svg"
                  alt="Album Art"
                  width="150"
                  height="150"
          />
        </div>
        <button class="play-button">
          <img class="play-icon" src="https://alex-fortunato.github.io/Website/playbar/assets/playbutton-icon.svg" class="button-icon" />
          <img class="pause-icon" src="https://alex-fortunato.github.io/Website/playbar/assets/pausebutton-icon.svg" class="button-icon" style="display: none;" />
        </button>
        <div class="time-info">
          <span class="current-time">0:00</span>
          <span class="total-time">0:00</span>
        </div>
        <canvas class="waveform-canvas"></canvas>
      </div>
    </div>
  </div>

  <!-- Player 2 -->
  <div class="player-container" data-player-id="player2">
    <!-- Song info is now placed before the visualization wrapper -->
    <div class="song-info">
      <div class="song-title">The Kiss (Excerpt)/ Budapest Art Orchestra</div>
    </div>

    <div class="visualization-wrapper">
      <div class="visualization-container">
        <div class="album-art">
          <img
                  src="https://alex-fortunato.github.io/Website/playbar/assets/red-bull-logo.svg"
                  alt="Album Art"
                  width="150"
                  height="150"
          />
        </div>
        <button class="play-button">
          <img class="play-icon" src="https://alex-fortunato.github.io/Website/playbar/assets/playbutton-icon.svg" class="button-icon" />
          <img class="pause-icon" src="https://alex-fortunato.github.io/Website/playbar/assets/pausebutton-icon.svg" class="button-icon" style="display: none;" />
        </button>
        <div class="time-info">
          <span class="current-time">0:00</span>
          <span class="total-time">0:00</span>
        </div>
        <canvas class="waveform-canvas"></canvas>
      </div>
    </div>
  </div>

  <!-- Add more player instances as needed here -->
</div>

<!-- Hidden audio upload - keeping in case I want upload functionality in Squarespace -->
<input
        type="file"
        id="audioUpload"
        accept="audio/*"
        style="display: none;"
/>

<!--<script src="visualizer.js"></script>-->
<!--</body>-->
<!--</html>-->

<style>
/*body {*/
/*  font-family:*/
/*          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,*/
/*          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;*/
/*  margin: 0;*/
/*  padding: 20px;*/
/*  display: flex;*/
/*  flex-direction: column;*/
/*  align-items: center;*/
/*  background-color: #2a2a2a;*/
/*  color: #e0e0e0;*/
/*}*/

/*.player-container {*/
/*  width: 100%;*/
/*  max-width: 600px;*/
/*  background-color: transparent;*/
/*  border-radius: 8px;*/
/*  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);*/
/*  padding: 20px;*/
/*  margin-bottom: 20px;*/
/*  overflow: visible;*/
/*}*/

.playlist-container {
  width: 100%;
  max-width: 900px;
  margin: 0 auto;
}


/*.song-title {*/
/*  font-weight: bold;*/
/*  margin-bottom: 5px;*/
/*}*/

.player-container {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 900px;
  background-color: transparent;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 30px;
  overflow: visible
}

.song-info {
  margin-bottom: 0;
  margin-top: 0;
  padding: 0;
  position: relative;
  z-index: 20;
  order: -1;

}

.song-title {
  font-weight: bold;
  margin-left: 250px;
  margin-top: 20px;
  margin-bottom: 0;
  font-size: 1.1em;
  position: relative;
  z-index: 20;
  color: red;
}


/*controls {*/
/*  display: flex;*/
/*  align-items: center;*/
/*  margin-bottom: 15px;*/
/*}*/



.time-info {
  position: absolute;
  width: 100%;
  font-size: 0.8em;
  color: #ff0000;
  pointer-events: none;
  z-index: 30;


}

.time-info .current-time,
.time-info span.current-time {
  position: absolute;
  /*left: var(--waveform-left, 210px);*/
  /*left: 190px;*/
  top: 50%;
  transform: translatey(-50%);
  white-space: nowrap;
  background-color: transparent;
  padding: 2px 5px;
  border-radius: 3px;
}

.time-info .total-time,
.time-info span.total-time {
  position: absolute;
  /*left: var(--waveform-end, 700px);*/
  /*right: -10px;*/
  top: 50%;
  transform: translatey(-50%);
  white-space: nowrap;
  background-color: transparent;
  padding: 2px 5px;
  border-radius: 3px;
}

/* Updated visualization layout for wider waveform */
.visualization-wrapper {
  width: 100%;
  display: flex;
  justify-content: center;
  margin-bottom: 5px;
  overflow: visible;
}

.visualization-container {
  width: 100%; /* Expanded to full width */
  height: 120px;
  position: relative;
  display: flex;
  align-items: center;
  overflow: visible;
}

.album-art {
  position: absolute;
  width: 150px;
  height: 150px;
  display: flex;
/*  align-items: center; */
  justify-content: center;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  z-index: 5;
}

.album-art img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.play-button {
  position: relative;
  left: 140px; /* Position after the album art */
  z-index: 10;
  background-color: transparent;
  color: white;
  border: none;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 14px;
}

.button-icon,
.play-icon,
.pause-icon {
  width: 24px;
  height: 24px;
  display: block;
  margin: 0 auto;
}

/*.play-button {*/
/*  display: flex;*/
/*  align-items: center;*/
/*  justify-content: center;*/
/*}*/

/* Canvas takes up the entire container but with padding on the left */
.waveform-canvas,
canvas.waveform-canvas {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 4px;
  background-color: transparent;
  padding-right: 40px;
  padding-left: 0; /* Space for album art (150px) + play button (40px) + margins */
  box-sizing: content-box;
  overflow: visible;

}

/* Increase the player container max-width for more space */
/*.player-container {*/
/*  width: 100%;*/
/*  max-width: 900px; !* Increased from 600px *!*/
/*  background-color: transparent;*/
/*  border-radius: 8px;*/
/*  !*box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);*!*/
/*  padding: 20px;*/
/*  margin-bottom: 20px;*/
/*  overflow: visible;*/
/*}*/

/*!* Also increase settings container to match *!*/
/*.settings {*/
/*  width: 100%;*/
/*  max-width: 900px; !* Increased from 600px *!*/
/*  background-color: #333333;*/
/*  border-radius: 8px;*/
/*  padding: 20px;*/
/*  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);*/
/*}*/

@media (max-width: 600px) {
  .visualization-container {
    height: 100px;
    margin-bottom: 40px;
  }

  .album-art {
    width: 120px;
    height: 120px;
  }

  .play-button {
    left: 135px;
  }
}
/*  canvas {*/
/*    padding-left: 180px;*/
/*  }*/
/*}*/

/*@media (max-width: 500px) {*/
/*  .visualization-container {*/
/*    height: 80px;*/
/*  }*/

/*  .album-art {*/
/*    width: 80px;*/
/*    height: 80px;*/
/*  }*/

/*  .play-button {*/
/*    left: 95px;*/
/*    width: 30px;*/
/*    height: 30px;*/
/*  }*/

/*  canvas {*/
/*    padding-left: 140px;*/
/*  }*/
/*}*/
</style>

<script>
// Audio Player Manager
class AudioPlayerManager {
    constructor() {
        this.players = new Map(); // Store all player instances
        this.currentlyPlaying = null; // Track which player is currently playing
        this.audioContext = null; // Shared audio context
        this.analyser = null; // Shared analyser

        // Initialize shared audio context
        this.initAudioContext();

        // Configuration options
        this.barCount = 250;
        this.barSpacing = 0;
        this.sensitivity = 12;
        this.minBarHeight = 0.5;
        this.barColor = "#FF0000";
        this.progressColor = "#FFFFFF";

        // Initialize the players
        this.initPlayers();

        // Handle window resize
        window.addEventListener("resize", () => {
            this.players.forEach(player => {
                player.resizeCanvas();
                player.updateTimeInfoPositions();
                if (!player.isPlaying && player.staticWaveformData) {
                    player.drawStaticWaveform();
                }
            });
        });
    }

    // Initialize shared audio context
    initAudioContext() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 1024;
    }

    // Initialize all player instances on the page
    initPlayers() {
        const playerContainers = document.querySelectorAll('.player-container');

        playerContainers.forEach((container, index) => {
            const playerId = container.dataset.playerId || `player${index + 1}`;
            const songData = {
                id: playerId,
                title: container.querySelector('.song-title').textContent.trim(),
                audio: this.getSongUrlById(playerId),
                albumArt: container.querySelector('.album-art img').src
            };

            // Create a new player
            const player = new AudioPlayer(this, container, songData);
            this.players.set(playerId, player);
        });
    }

    // Get song URL based on player ID - customize this for your audio sources
    getSongUrlById(playerId) {
        const audioSources = {
            player1: "https://dl.dropboxusercontent.com/scl/fi/vzk3mg3iaftu7mv8yf6z1/AF_BullFight_Mockup_Master.mp3?rlkey=4dmiwmjkkhv71daw3xbv6yigp&dl=03",
            player2: "https://dl.dropboxusercontent.com/scl/fi/vzk3mg3iaftu7mv8yf6z1/AF_BullFight_Mockup_Master.mp3?rlkey=4dmiwmjkkhv71daw3xbv6yigp&dl=03"
            // Add more songs as needed
        };

        return audioSources[playerId] || "";
    }

    // Pause all players except the one that was just activated
    pauseAllExcept(exceptPlayerId) {
        this.players.forEach((player, playerId) => {
            if (playerId !== exceptPlayerId && player.isPlaying) {
                player.pause();
            }
        });
    }
}

// Individual Audio Player
class AudioPlayer {
    constructor(manager, container, songData) {
        this.manager = manager;
        this.container = container;
        this.songData = songData;

        // DOM elements
        this.canvas = container.querySelector('.waveform-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.playButton = container.querySelector('.play-button');
        this.playIcon = container.querySelector('.play-icon');
        this.pauseIcon = container.querySelector('.pause-icon');
        this.currentTimeDisplay = container.querySelector('.current-time');
        this.totalTimeDisplay = container.querySelector('.total-time');

        // State variables
        this.audioElement = null;
        this.audioSource = null;
        this.isPlaying = false;
        this.animationId = null;
        this.staticWaveformData = null;
        this.previousHeights = new Array(manager.barCount).fill(0);

        // Initialize the player
        this.initAudio();
        this.setupEventListeners();
        this.resizeCanvas();
    }

    // Initialize audio element
    initAudio() {
        this.audioElement = new Audio();
        this.audioElement.crossOrigin = "anonymous";
        this.audioElement.src = this.songData.audio;

        // Add ended event listener
        this.audioElement.addEventListener("ended", () => this.handleAudioEnd());

        // Connect to audio context when metadata is loaded
        this.audioElement.addEventListener("loadedmetadata", async () => {
            this.updateTimeDisplays();
            try {
                await this.analyzeAudio();
            } catch (err) {
                console.error("Error analyzing audio:", err);
            }
        });

        // Handle loading errors
        this.audioElement.addEventListener("error", (e) => {
            console.error("Error loading audio:", e);
        });
    }

    // Set up event listeners
    setupEventListeners() {
        // Play/pause button
        this.playButton.addEventListener('click', () => this.togglePlayback());

        // Canvas click for scrubbing
        this.canvas.addEventListener('click', (event) => this.handleCanvasClick(event));

        // Hover effect
        this.canvas.addEventListener('mousemove', () => {
            this.canvas.style.cursor = 'pointer';
        });
    }

    // Toggle playback
    togglePlayback() {
        if (!this.audioElement || !this.audioElement.src) {
            console.error("No audio source available");
            return;
        }

        if (this.manager.audioContext.state === "suspended") {
            this.manager.audioContext.resume();
        }

        if (this.isPlaying) {
            this.pause();
        } else {
            // Pause any other playing tracks
            this.manager.pauseAllExcept(this.songData.id);

            // Set up audio source if not already connected
            if (!this.audioSource) {
                this.audioSource = this.manager.audioContext.createMediaElementSource(this.audioElement);
                this.audioSource.connect(this.manager.analyser);
                this.manager.analyser.connect(this.manager.audioContext.destination);
            }

            // Play this track
            this.play();
        }
    }

    // Play the audio
    play() {
        // Make sure we have analyzed audio data
        if (!this.staticWaveformData && this.audioElement.duration > 0) {
            this.analyzeAudio().then(() => {
                this.startPlayback();
            });
        } else {
            this.startPlayback();
        }
    }

    // Start playback
    startPlayback() {
        this.audioElement.play();
        this.playIcon.style.display = "none";
        this.pauseIcon.style.display = "block";
        this.isPlaying = true;
        this.manager.currentlyPlaying = this.songData.id;
        this.drawVisualization();
    }

    // Pause the audio
    pause() {
        this.audioElement.pause();
        this.playIcon.style.display = "block";
        this.pauseIcon.style.display = "none";
        this.isPlaying = false;

        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        // Redraw static waveform with current progress
        this.drawStaticWaveform();
    }

    // Handle audio end
    handleAudioEnd() {
        this.isPlaying = false;
        this.playIcon.style.display = "block";
        this.pauseIcon.style.display = "none";

        // Stop the animation
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }

        // Reset the audio to beginning
        this.audioElement.currentTime = 0;

        // Update displays
        this.updateTimeDisplays();

        // Redraw static waveform
        this.drawStaticWaveform();
    }

    // Handle canvas click for scrubbing
    handleCanvasClick(event) {
        if (!this.audioElement || !this.audioElement.src) return;

        // Get click position relative to canvas
        const rect = this.canvas.getBoundingClientRect();
        const clickX = event.clientX - rect.left;

        // Get waveform start position
        const paddingLeft = this.getWaveformStartX();

        // Only process the click if it's in the waveform area
        if (clickX < paddingLeft) {
            console.log("Click ignored - in album art/play button area");
            return;
        }

        // Calculate the scaling factor between browser and canvas coordinates
        const canvasScaleFactor = this.canvas.width / this.canvas.clientWidth;

        // Scale the click position from browser coordinates to canvas coordinates
        const adjustedClickX = (clickX - paddingLeft) * canvasScaleFactor;

        // Calculate the usable width in canvas coordinates
        const usableWidth = this.canvas.width - paddingLeft;

        // Calculate percentage using properly scaled coordinates
        const clickPercent = adjustedClickX / usableWidth;

        // Clamp percentage between 0 and 1
        const clampedPercent = Math.max(0, Math.min(1, clickPercent));

        // Set the audio playback position
        if (this.audioElement.duration) {
            this.audioElement.currentTime = clampedPercent * this.audioElement.duration;

            // Update the visualization
            if (this.isPlaying) {
                // If playing, the animation frame will handle it
            } else {
                // If paused, redraw static waveform with new position
                this.updateTimeDisplays();
                this.drawStaticWaveform();
            }
        }
    }

    // Get the waveform start X position
    getWaveformStartX() {
        const art = this.container.querySelector(".album-art");
        const button = this.container.querySelector(".play-button");

        const artW = art?.offsetWidth || 150;
        const btnW = button?.offsetWidth || 10;
        const margin = -20;

        const canvasPadding = parseFloat(getComputedStyle(this.canvas).paddingLeft) || 0;
        return artW + btnW + margin + canvasPadding;
    }

    // Resize canvas to match display size
    resizeCanvas() {
        const containerWidth = this.canvas.clientWidth - 60;
        const containerHeight = this.canvas.clientHeight;

        if (this.canvas.width !== containerWidth || this.canvas.height !== containerHeight) {
            this.canvas.width = containerWidth;
            this.canvas.height = containerHeight;
        }
        this.updateTimeInfoPositions();
    }

    // Update time displays
    updateTimeDisplays() {
        if (this.audioElement && !isNaN(this.audioElement.duration)) {
            this.currentTimeDisplay.textContent = this.formatTime(this.audioElement.currentTime);
            this.totalTimeDisplay.textContent = this.formatTime(this.audioElement.duration);
        }
    }

    // Format time in MM:SS
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return mins + ":" + (secs < 10 ? "0" : "") + secs;
    }

    // Update time info positions
    updateTimeInfoPositions() {
        const waveformStartX = this.getWaveformStartX();
        const currentTimeElement = this.currentTimeDisplay;
        const totalTimeElement = this.totalTimeDisplay;
        const playButton = this.playButton;
        const visualizationsContainer = this.container.querySelector(".visualization-container");

        // Get dimensions
        const playButtonRect = playButton.getBoundingClientRect();
        const containerRect = visualizationsContainer.getBoundingClientRect();
        const containerWidth = containerRect.width;

        // Set styles for better visibility
        currentTimeElement.style.backgroundColor = "transparent";
        totalTimeElement.style.backgroundColor = "transparent";
        currentTimeElement.style.color = "rgba(255,0,0,0.59)";
        totalTimeElement.style.color = "rgba(255,0,0,0.59)";

        // Calculate play button right edge relative to container
        const playButtonRightEdge = playButtonRect.right - containerRect.left;

        if (containerWidth < 600) {
            // Responsive positioning for small screens
            const verticalOffset = -60;
            const horizontalOffset = 5;

            currentTimeElement.style.left = `${playButton.offsetLeft + horizontalOffset}px`;
            currentTimeElement.style.top = `${playButton.offsetTop + playButton.offsetHeight + verticalOffset}px`;
            currentTimeElement.style.transform = "none";

            totalTimeElement.style.left = "auto";
            totalTimeElement.style.right = "5px";
            totalTimeElement.style.top = `${playButton.offsetTop + playButton.offsetHeight + verticalOffset}px`;
            totalTimeElement.style.transform = "none";
        } else {
            // Standard positioning
            const timePadding = 10;

            currentTimeElement.style.left = `${playButtonRightEdge + timePadding}px`;
            currentTimeElement.style.top = "50%";
            currentTimeElement.style.bottom = "auto";
            currentTimeElement.style.transform = "translateY(-50%)";

            totalTimeElement.style.left = "auto";
            totalTimeElement.style.right = "5px";
            totalTimeElement.style.top = "50%";
            totalTimeElement.style.transform = "translateY(-50%)";
        }
    }

    // Analyze audio to create waveform data
    async analyzeAudio() {
        if (!this.manager.audioContext || !this.audioElement.src) return;

        try {
            // Create a temporary offline audio context for analysis
            const offlineCtx = new OfflineAudioContext(
                1, // Single channel for analysis
                this.audioElement.duration * this.manager.audioContext.sampleRate,
                this.manager.audioContext.sampleRate,
            );

            // Fetch the audio file
            const response = await fetch(this.audioElement.src);
            const arrayBuffer = await response.arrayBuffer();

            // Decode the audio data
            const audioData = await offlineCtx.decodeAudioData(arrayBuffer);

            // Create buffer source
            const source = offlineCtx.createBufferSource();
            source.buffer = audioData;

            // Create analyzer
            const offlineAnalyser = offlineCtx.createAnalyser();
            offlineAnalyser.fftSize = 1024;

            // Connect source to analyzer
            source.connect(offlineAnalyser);
            offlineAnalyser.connect(offlineCtx.destination);

            // Start the source
            source.start(0);

            // Generate samples across the audio track
            const sampleSize = this.manager.barCount;
            this.staticWaveformData = new Array(sampleSize).fill(0);

            // Process the audio in chunks
            const samplesPerBar = Math.floor(audioData.length / sampleSize);

            // Get the audio data
            const channelData = audioData.getChannelData(0);

            // Calculate average amplitude for each segment
            for (let i = 0; i < sampleSize; i++) {
                const startSample = i * samplesPerBar;
                const endSample = Math.min(startSample + samplesPerBar, audioData.length);
                let sum = 0;

                // Calculate average amplitude
                for (let j = startSample; j < endSample; j++) {
                    sum += Math.abs(channelData[j]);
                }

                // Store average value (normalized 0-255 for consistency with analyser output)
                this.staticWaveformData[i] = (sum / samplesPerBar) * 255;
            }

            // Draw the static waveform
            this.drawStaticWaveform();
        } catch (error) {
            console.error("Error analyzing audio:", error);

            // Fallback to simple waveform if analysis fails
            if (!this.staticWaveformData) {
                // Create a simple default waveform
                this.staticWaveformData = new Array(this.manager.barCount).fill(0).map(
                    () => Math.random() * 40 + 10,
                );
                this.drawStaticWaveform();
            }
        }
    }

    // Draw the static waveform
    drawStaticWaveform() {
        if (!this.staticWaveformData) return;

        this.resizeCanvas();

        // Clear the canvas with transparent background
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Get the waveform start position
        const paddingLeft = this.getWaveformStartX();

        // Calculate the actual usable width for the waveform
        const totalCanvasWidth = this.canvas.width;
        const usableWidth = totalCanvasWidth - paddingLeft;

        // Calculate bar width based on usable width
        const totalBarSpace = this.manager.barSpacing * (this.manager.barCount - 1);
        const barWidth = (usableWidth - totalBarSpace) / this.manager.barCount;

        // Center line is in the middle of the canvas height
        const centerY = this.canvas.height / 2;

        // Draw bars
        for (let i = 0; i < this.manager.barCount; i++) {
            // Normalize raw static data (0–255 → 0–1)
            const normalized = this.staticWaveformData[i] / 255;

            // Apply sensitivity, but cap at 1
            const boosted = Math.min(normalized * (this.manager.sensitivity / 5), 1);

            // Scale into 45% of full canvas height
            const rawHeight = boosted * (this.canvas.height * 0.45);

            // Clamp between minBarHeight and half‐canvas
            const barHeight = Math.min(
                Math.max(rawHeight, this.manager.minBarHeight),
                this.canvas.height / 2
            );

            // Calculate X position
            const x = paddingLeft + i * (barWidth + this.manager.barSpacing);

            // Compute progress for coloring
            let progressPosition = 0;
            if (this.audioElement && !isNaN(this.audioElement.duration)) {
                progressPosition = paddingLeft
                    + (this.audioElement.currentTime / this.audioElement.duration) * usableWidth;
            }
            const isPlayed = x <= progressPosition;
            this.ctx.fillStyle = isPlayed ? this.manager.progressColor : this.manager.barColor;

            // Save the default state
            this.ctx.save();

            // Configure glow
            this.ctx.shadowColor = isPlayed ? this.manager.progressColor : this.manager.barColor;
            this.ctx.shadowBlur = 5;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;

            // Draw up & down from center
            this.ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
            this.ctx.fillRect(x, centerY, barWidth, barHeight);

            // Restore context
            this.ctx.restore();
        }
        this.updateTimeInfoPositions();
    }

    // Draw visualization during playback
    drawVisualization() {
        if (!this.manager.audioContext || !this.manager.analyser) return;

        this.animationId = requestAnimationFrame(() => this.drawVisualization());
        this.resizeCanvas();

        const bufferLength = this.manager.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);

        // Get frequency data from the audio
        this.manager.analyser.getByteFrequencyData(dataArray);

        // Clear the canvas with transparent background
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Update time displays
        this.updateTimeDisplays();

        // Use the fixed starting X position for the waveform
        const paddingLeft = this.getWaveformStartX();

        // Calculate the actual usable width for the waveform
        const totalCanvasWidth = this.canvas.width;
        const usableWidth = totalCanvasWidth - paddingLeft;

        // Calculate bar width based on usable width
        const totalBarSpace = this.manager.barSpacing * (this.manager.barCount - 1);
        const barWidth = (usableWidth - totalBarSpace) / this.manager.barCount;

        // Get the sensitivity factor
        const sensitivityFactor = this.manager.sensitivity / 5;

        // Calculate the progress position
        let progressPosition = 0;
        if (
            this.audioElement &&
            !isNaN(this.audioElement.duration) &&
            this.audioElement.duration > 0
        ) {
            progressPosition = paddingLeft + (this.audioElement.currentTime / this.audioElement.duration) * usableWidth;
        }

        this.updateTimeInfoPositions();

        // Draw the live visualization
        this.drawLiveVisualization(
            dataArray,
            barWidth,
            sensitivityFactor,
            progressPosition
        );
    }

    // Draw live visualization during playback
    drawLiveVisualization(dataArray, barWidth, sensitivityFactor, progressPosition) {
        const easingUp = 1.5;
        const easingDown = 1.5;
        const bufferLength = this.manager.analyser.frequencyBinCount;

        const paddingLeft = this.getWaveformStartX();
        const centerY = this.canvas.height / 2;

        for (let i = 0; i < this.manager.barCount; i++) {
            const normIndex = i / this.manager.barCount;
            const logIndex = Math.floor(Math.pow(normIndex, 2) * (bufferLength - 1));
            const dataIndex = Math.min(logIndex, bufferLength - 1);
            let value = dataArray[dataIndex] || 0;
            const lowEndCut = 1 - Math.pow(1 - normIndex, 1.5);
            value *= lowEndCut;
            const normalized = value / 255;
            const boosted = Math.min(normalized * sensitivityFactor, 1);
            const targetHeight = boosted * (this.canvas.height * 0.45);

            const currentHeight = this.previousHeights[i] || 0;
            const easeFactor = targetHeight > currentHeight ? easingUp : easingDown;
            const easedHeight = currentHeight + (targetHeight - currentHeight) * easeFactor;
            this.previousHeights[i] = easedHeight;

            const barHeight = Math.min(Math.max(easedHeight, this.manager.minBarHeight), this.canvas.height / 2);
            const x = paddingLeft + i * (barWidth + this.manager.barSpacing);
            const isPlayed = x <= progressPosition;

            // Decide fill & glow color
            const fillCol = isPlayed ? this.manager.progressColor : this.manager.barColor;

            // Save & configure shadow
            this.ctx.save();
            this.ctx.fillStyle = fillCol;
            this.ctx.shadowColor = fillCol;
            this.ctx.shadowBlur = 5;
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;

            // Draw bar halves
            this.ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
            this.ctx.fillRect(x, centerY, barWidth, barHeight);

            // Restore to clear shadow settings
            this.ctx.restore();
        }
    }
}

// Initialize the player manager when the DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
    const playerManager = new AudioPlayerManager();
});
</script>
